# 二维几何
- 常规
```cpp
using ll = long long;
using ld = long double;

const double eps = 1e-8;
const double inf = 1e20;
const double pi = acos(-1.0);

template <typename T>
inline void read(T &x) {
    x = 0; T f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    x *= f;
}

int sgn(double x) {
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    else return 1;
}
```
- 点
```cpp
struct Point {
    double x, y;
    Point() {}
    Point(double _x, double _y) : x(_x), y(_y) {}

    void input() { scanf("%lf %lf", &x, &y); }
    void output() { printf("%.10lf %.10lf\n", x, y); }
    bool operator==(Point b) const { return sgn(x - b.x) == 0 && sgn(y - b.y) == 0; }
    bool operator<(Point b) const { return sgn(x - b.x) == 0 ? sgn(y - b.y) < 0 : sgn(x - b.x) < 0; }
    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }
    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }
    Point operator*(const double &k) const { return Point(x * k, y * k); }
    Point operator/(const double &k) const { return Point(x / k, y / k); }

    double operator*(const Point &b) const { return x * b.x + y * b.y; }  // dot product
    double operator^(const Point &b) const { return x * b.y - y * b.x; }  // cross product of 2d points
    double len() { return hypot(x, y); }                                  // length from origin
    double len2() { return x * x + y * y; }
    double dis(Point p) { return hypot(x - p.x, y - p.y); }  // distance from p
    // 计算pa pb夹角，这个点看a,b所成的夹角
    double rad(Point a, Point b) {
        Point p = *this;
        return fabs(atan2(fabs((a - p) ^ (b - p)), (a - p) * (b - p)));
    }
    Point rotleft() {
        return Point(-y, x);  // 逆时针旋转90
    }
    Point rotright() {
        return Point(y, -x);  // 顺时针旋转90
    }
    // 绕着点p逆时针旋转angle
    Point rotate(Point p, double angle) {
        Point v = (*this) - p;
        double c = cos(angle);
        double s = sin(angle);
        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);
    }
};
```
- 线
```cpp
struct Line {
	Point u, v;
	Line(){}
	Line(Point _u, Point _v) : u(_u), v(_v){}
	bool operator == (Line l) { return (u == l.u) && (v == l.v); }
	
	void input() { u.input(); v.input(); }
	double length() {return u.dis(v); }
	
	// ralation of point and line(segment): 点和直线(线段)关系
	// 1:left  2:right  3:on segment  4: on line front  5:on line back
	int relation(Point p) {
		int c = sgn((p-u)^(v-u));
		if(c < 0) return 1;
		else if(c > 0) return 2;
		else { // on (line or segment)
			if(sgn((p-u)*(p-v)) <= 0) return 3; // on segment
			if(sgn((p-u)*(v-u)) > 0) return 4; // on_line_front
			else return 5; // on_line_back
		}
	}
	
	// relation of two lines 直线与直线关系 
	// 0:平行 1:重合  2:正交  3:其他 
	int line_relation(Line l) {
		if(sgn((v-u)*(l.v-l.u)) == 0) return 2;
		//叉乘为0 →共线向量(平行or重合) 
		if(sgn((v-u)^(l.v-l.u)) == 0) return l.relation(u) > 2;
		return 3; 
	} 
	
	// 两条线段相交判断 
	// 2 规范相交 1 非规范相交 0 不相交 
	int segcrossseg(Line l) {
		int d1 = sgn((v-u)^(l.u-u));
		int d2 = sgn((v-u)^(l.v-u));
		int d3 = sgn((l.v-l.u)^(u-l.u));
		int d4 = sgn((l.v-l.u)^(v-l.u));
		if((d1^d2) == -2 && (d3^d4) == -2) return 2;
		return (d1==0 && sgn((l.u-u)*(l.u-v))<=0) ||
               (d2==0 && sgn((l.v-u)*(l.v-v))<=0) ||
               (d3==0 && sgn((u-l.u)*(u-l.v))<=0) ||
               (d4==0 && sgn((v-l.u)*(v-l.v))<=0);
	}
	
	//求两直线的交点
    //要保证两直线不平行或重合
    Point crosspoint(Line l){
    	double a1 = (l.v-l.u)^(u-l.u);
    	double a2 = (l.v-l.u)^(v-l.u);
    	return Point((u.x*a2-v.x*a1)/(a2-a1), (u.y*a2-v.y*a1)/(a2-a1));
    }
	
	// dis: point to line 点到直线的距离 
	double dispointtoline(Point p) { return fabs((p-u)^(v-u))/length(); }
	
	// dis : point to seg 点到线段的距离
	double dispointtoseg(Point p){
    	if(sgn((p-u)*(v-u))<0 || sgn((p-v)*(u-v))<0) 
			return min(p.dis(u),p.dis(v));
    	return dispointtoline(p);
    } 
	// dis: seg to seg 线段到线段的距离
    double dissegtoseg(Line l){
    	if(segcrossseg(l)) return 0; // 线段相交，距离就是0
    	return min(min(dispointtoseg(l.u),dispointtoseg(l.v)),
		           min(l.dispointtoseg(u),l.dispointtoseg(v)));
    }
	
	// project point p on line(u,v) 点p在直线上的投影 
	Point project(Point p) {
		return u + ( ((v-u)*((v-u)*(p-u)))/((v-u).len2()) );
		//return p*
	}
	// 点p关于直线的对称点 
	Point symmetry(Point p) {
		Point q = project(p); // 连线中点 
		return Point(2*q.x-p.x, 2*q.y-p.y);
	}
};
```
- 多边形
```cpp
const int maxp = 1e5 + 5;
struct Polygon {
    int n;  // size of polygon
    vector<Point> p;
    vector<Line> l;

    Polygon() {
        p = vector<Point>(maxp);
        l = vector<Line>(maxp);
    }
    void input(int _n) {
        n = _n;
        for (int i = 0; i < n; i++) p[i].input();
    }
    void output() {
        cerr << "n = " << n << '\n';
        for (int i = 0; i < n; i++) p[i].output();
    }
    void add(Point q) {
        p[n++] = q;  // add a point at the end of the list
    }
    void getline() {  // populate line array
        for (int i = 0; i < n; i++) l[i] = Line(p[i], p[(i + 1) % n]);
    }
    // 判断是不是凸的
    bool isconvex() {
        bool s[2];
        mem(s, false);
        for (int i = 0; i < n; i++) {
            int j = (i + 1) % n;
            int k = (j + 1) % n;
            s[sgn((p[j] - p[i]) ^ (p[k] - p[i])) + 1] = true;
            if (s[0] && s[2])
                return false;
        }
        return true;
    }
    // 判断点与任意多边形的关系
    // 3:点上  2:边上  1:内部  0:外部  (在点上 一定 在边上)
    int point_relation(Point q) {
        for (int i = 0; i < n; i++)
            if (p[i] == q)
                return 3;
        getline();
        for (int i = 0; i < n; i++) if (l[i].relation(q) == 3) return 2;
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            int j = (i + 1) % n;
            int k = sgn((q - p[j]) ^ (p[i] - p[j]));
            int u = sgn(p[i].y - q.y);
            int v = sgn(p[j].y - q.y);
            if (k > 0 && u < 0 && v >= 0)
                cnt++;
            if (k < 0 && v < 0 && u >= 0)
                cnt--;
        }
        return cnt != 0;
    }

    double getCircumference() {
        double sum = 0;
        for (int i = 0; i < n; i++) sum += p[i].dis(p[(i + 1) % n]);
        return sum;
    }
    double getArea() {
        double sum = 0;
        for (int i = 0; i < n; i++) sum += (p[i] ^ p[(i + 1) % n]);
        return fabs(sum) / 2;
    }

    struct cmp {
        Point q;
        cmp(const Point &q0) { q = q0; }
        bool operator()(const Point &aa, const Point &bb) {
            Point a = aa, b = bb;
            int d = sgn((a - q) ^ (b - q));
            if (d == 0)
                return sgn(a.dis(q) - b.dis(q)) < 0;
            return d > 0;
        }
    };
    // 极角排序
    // 首先找到最左下角的点，需要重载Point的 < 操作符
    void norm() {
        Point mi = p[0];
        for (int i = 0; i < n; i++) mi = min(mi, p[i]);
        sort(p.begin(), p.begin() + n, cmp(mi));
    }
    // 得到凸包 Andrew
    // 得到的凸包里面的的点编号是 0~n-1
    Polygon getConvex() {
        Polygon convex;
        // sort(p, p + n);
        sort(p.begin(), p.begin() + n);
        convex.n = n;

        for (int i = 0; i < min(n, 2); i++) {
            convex.p[i] = p[i];
        }
        if (convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n--;
        if (n <= 2) return convex;

        int &top = convex.n;
        top = 1;
        for (int i = 2; i < n; i++) {
            while (top && sgn((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) <= 0) top--;
            convex.p[++top] = p[i];
        }
        int temp = top;
        convex.p[++top] = p[n - 2];
        for (int i = n - 3; i >= 0; i--) {
            while (top != temp && sgn((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) <= 0) top--;
            convex.p[++top] = p[i];
        }
        if (convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n--;
        convex.norm();  // 原来得到的是顺时针的点，排序后逆时针
        return convex;
    }
};
```